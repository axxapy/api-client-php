<?php
/**
 * FeatureFlagsApi
 * PHP version 5
 *
 * @category Class
 * @package  LaunchDarklyApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * LaunchDarkly REST API
 *
 * Build custom integrations with the LaunchDarkly REST API
 *
 * OpenAPI spec version: 3.1.0
 * Contact: support@launchdarkly.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace LaunchDarklyApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use LaunchDarklyApi\ApiException;
use LaunchDarklyApi\Configuration;
use LaunchDarklyApi\HeaderSelector;
use LaunchDarklyApi\ObjectSerializer;

/**
 * FeatureFlagsApi Class Doc Comment
 *
 * @category Class
 * @package  LaunchDarklyApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class FeatureFlagsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation copyFeatureFlag
     *
     * Copies the feature flag configuration from one environment to the same feature flag in another environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagCopyBody $feature_flag_copy_body Copy feature flag configurations between environments. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlag
     */
    public function copyFeatureFlag($project_key, $feature_flag_key, $feature_flag_copy_body)
    {
        list($response) = $this->copyFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $feature_flag_copy_body);
        return $response;
    }

    /**
     * Operation copyFeatureFlagWithHttpInfo
     *
     * Copies the feature flag configuration from one environment to the same feature flag in another environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagCopyBody $feature_flag_copy_body Copy feature flag configurations between environments. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlag, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $feature_flag_copy_body)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->copyFeatureFlagRequest($project_key, $feature_flag_key, $feature_flag_copy_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyFeatureFlagAsync
     *
     * Copies the feature flag configuration from one environment to the same feature flag in another environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagCopyBody $feature_flag_copy_body Copy feature flag configurations between environments. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFeatureFlagAsync($project_key, $feature_flag_key, $feature_flag_copy_body)
    {
        return $this->copyFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $feature_flag_copy_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyFeatureFlagAsyncWithHttpInfo
     *
     * Copies the feature flag configuration from one environment to the same feature flag in another environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagCopyBody $feature_flag_copy_body Copy feature flag configurations between environments. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $feature_flag_copy_body)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->copyFeatureFlagRequest($project_key, $feature_flag_key, $feature_flag_copy_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyFeatureFlag'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagCopyBody $feature_flag_copy_body Copy feature flag configurations between environments. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function copyFeatureFlagRequest($project_key, $feature_flag_key, $feature_flag_copy_body)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling copyFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling copyFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_copy_body' is set
        if ($feature_flag_copy_body === null || (is_array($feature_flag_copy_body) && count($feature_flag_copy_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_copy_body when calling copyFeatureFlag'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($feature_flag_copy_body)) {
            $_tempBody = $feature_flag_copy_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFeatureFlag
     *
     * Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFeatureFlag($project_key, $feature_flag_key)
    {
        $this->deleteFeatureFlagWithHttpInfo($project_key, $feature_flag_key);
    }

    /**
     * Operation deleteFeatureFlagWithHttpInfo
     *
     * Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFeatureFlagWithHttpInfo($project_key, $feature_flag_key)
    {
        $returnType = '';
        $request = $this->deleteFeatureFlagRequest($project_key, $feature_flag_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFeatureFlagAsync
     *
     * Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFeatureFlagAsync($project_key, $feature_flag_key)
    {
        return $this->deleteFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFeatureFlagAsyncWithHttpInfo
     *
     * Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key)
    {
        $returnType = '';
        $request = $this->deleteFeatureFlagRequest($project_key, $feature_flag_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFeatureFlag'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFeatureFlagRequest($project_key, $feature_flag_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling deleteFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling deleteFeatureFlag'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExpiringUserTargets
     *
     * Get expiring user targets for feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\UserTargetingExpirationForFlags
     */
    public function getExpiringUserTargets($project_key, $environment_key, $feature_flag_key)
    {
        list($response) = $this->getExpiringUserTargetsWithHttpInfo($project_key, $environment_key, $feature_flag_key);
        return $response;
    }

    /**
     * Operation getExpiringUserTargetsWithHttpInfo
     *
     * Get expiring user targets for feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\UserTargetingExpirationForFlags, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExpiringUserTargetsWithHttpInfo($project_key, $environment_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags';
        $request = $this->getExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExpiringUserTargetsAsync
     *
     * Get expiring user targets for feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExpiringUserTargetsAsync($project_key, $environment_key, $feature_flag_key)
    {
        return $this->getExpiringUserTargetsAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExpiringUserTargetsAsyncWithHttpInfo
     *
     * Get expiring user targets for feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExpiringUserTargetsAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags';
        $request = $this->getExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExpiringUserTargets'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getExpiringUserTargets'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling getExpiringUserTargets'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getExpiringUserTargets'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureFlag
     *
     * Get a single feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlag
     */
    public function getFeatureFlag($project_key, $feature_flag_key, $env = null)
    {
        list($response) = $this->getFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $env);
        return $response;
    }

    /**
     * Operation getFeatureFlagWithHttpInfo
     *
     * Get a single feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlag, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $env = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->getFeatureFlagRequest($project_key, $feature_flag_key, $env);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureFlagAsync
     *
     * Get a single feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagAsync($project_key, $feature_flag_key, $env = null)
    {
        return $this->getFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $env)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureFlagAsyncWithHttpInfo
     *
     * Get a single feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $env = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->getFeatureFlagRequest($project_key, $feature_flag_key, $env);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureFlag'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureFlagRequest($project_key, $feature_flag_key, $env = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getFeatureFlag'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($env)) {
            $env = ObjectSerializer::serializeCollection($env, 'multi', true);
        }
        if ($env !== null) {
            $queryParams['env'] = ObjectSerializer::toQueryValue($env);
        }

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureFlagStatus
     *
     * Get the status for a particular feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlagStatus
     */
    public function getFeatureFlagStatus($project_key, $environment_key, $feature_flag_key)
    {
        list($response) = $this->getFeatureFlagStatusWithHttpInfo($project_key, $environment_key, $feature_flag_key);
        return $response;
    }

    /**
     * Operation getFeatureFlagStatusWithHttpInfo
     *
     * Get the status for a particular feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlagStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureFlagStatusWithHttpInfo($project_key, $environment_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatus';
        $request = $this->getFeatureFlagStatusRequest($project_key, $environment_key, $feature_flag_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlagStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureFlagStatusAsync
     *
     * Get the status for a particular feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusAsync($project_key, $environment_key, $feature_flag_key)
    {
        return $this->getFeatureFlagStatusAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureFlagStatusAsyncWithHttpInfo
     *
     * Get the status for a particular feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatus';
        $request = $this->getFeatureFlagStatusRequest($project_key, $environment_key, $feature_flag_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureFlagStatus'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureFlagStatusRequest($project_key, $environment_key, $feature_flag_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFeatureFlagStatus'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling getFeatureFlagStatus'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getFeatureFlagStatus'
            );
        }

        $resourcePath = '/flag-statuses/{projectKey}/{environmentKey}/{featureFlagKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureFlagStatusAcrossEnvironments
     *
     * Get the status for a particular feature flag across environments
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlagStatusAcrossEnvironments
     */
    public function getFeatureFlagStatusAcrossEnvironments($project_key, $feature_flag_key)
    {
        list($response) = $this->getFeatureFlagStatusAcrossEnvironmentsWithHttpInfo($project_key, $feature_flag_key);
        return $response;
    }

    /**
     * Operation getFeatureFlagStatusAcrossEnvironmentsWithHttpInfo
     *
     * Get the status for a particular feature flag across environments
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlagStatusAcrossEnvironments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureFlagStatusAcrossEnvironmentsWithHttpInfo($project_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatusAcrossEnvironments';
        $request = $this->getFeatureFlagStatusAcrossEnvironmentsRequest($project_key, $feature_flag_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlagStatusAcrossEnvironments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\UsageError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureFlagStatusAcrossEnvironmentsAsync
     *
     * Get the status for a particular feature flag across environments
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusAcrossEnvironmentsAsync($project_key, $feature_flag_key)
    {
        return $this->getFeatureFlagStatusAcrossEnvironmentsAsyncWithHttpInfo($project_key, $feature_flag_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureFlagStatusAcrossEnvironmentsAsyncWithHttpInfo
     *
     * Get the status for a particular feature flag across environments
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusAcrossEnvironmentsAsyncWithHttpInfo($project_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatusAcrossEnvironments';
        $request = $this->getFeatureFlagStatusAcrossEnvironmentsRequest($project_key, $feature_flag_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureFlagStatusAcrossEnvironments'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureFlagStatusAcrossEnvironmentsRequest($project_key, $feature_flag_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFeatureFlagStatusAcrossEnvironments'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getFeatureFlagStatusAcrossEnvironments'
            );
        }

        $resourcePath = '/flag-status/{projectKey}/{featureFlagKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureFlagStatuses
     *
     * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlagStatuses
     */
    public function getFeatureFlagStatuses($project_key, $environment_key)
    {
        list($response) = $this->getFeatureFlagStatusesWithHttpInfo($project_key, $environment_key);
        return $response;
    }

    /**
     * Operation getFeatureFlagStatusesWithHttpInfo
     *
     * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlagStatuses, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureFlagStatusesWithHttpInfo($project_key, $environment_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatuses';
        $request = $this->getFeatureFlagStatusesRequest($project_key, $environment_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlagStatuses',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureFlagStatusesAsync
     *
     * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusesAsync($project_key, $environment_key)
    {
        return $this->getFeatureFlagStatusesAsyncWithHttpInfo($project_key, $environment_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureFlagStatusesAsyncWithHttpInfo
     *
     * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusesAsyncWithHttpInfo($project_key, $environment_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatuses';
        $request = $this->getFeatureFlagStatusesRequest($project_key, $environment_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureFlagStatuses'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureFlagStatusesRequest($project_key, $environment_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFeatureFlagStatuses'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling getFeatureFlagStatuses'
            );
        }

        $resourcePath = '/flag-statuses/{projectKey}/{environmentKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureFlags
     *
     * Get a list of all features in the given project.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     * @param  bool $summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned. (optional)
     * @param  bool $archived When set to 1, archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags. (optional)
     * @param  float $limit The number of objects to return. Defaults to -1, which returns everything. (optional)
     * @param  bool $number Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. (optional)
     * @param  string $filter A comma-separated list of filters. Each filter is of the form field:value. (optional)
     * @param  string $sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. (optional)
     * @param  string $tag Filter by tag. A tag can be used to group flags across projects. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlags
     */
    public function getFeatureFlags($project_key, $env = null, $summary = null, $archived = null, $limit = null, $number = null, $filter = null, $sort = null, $tag = null)
    {
        list($response) = $this->getFeatureFlagsWithHttpInfo($project_key, $env, $summary, $archived, $limit, $number, $filter, $sort, $tag);
        return $response;
    }

    /**
     * Operation getFeatureFlagsWithHttpInfo
     *
     * Get a list of all features in the given project.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     * @param  bool $summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned. (optional)
     * @param  bool $archived When set to 1, archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags. (optional)
     * @param  float $limit The number of objects to return. Defaults to -1, which returns everything. (optional)
     * @param  bool $number Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. (optional)
     * @param  string $filter A comma-separated list of filters. Each filter is of the form field:value. (optional)
     * @param  string $sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. (optional)
     * @param  string $tag Filter by tag. A tag can be used to group flags across projects. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlags, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureFlagsWithHttpInfo($project_key, $env = null, $summary = null, $archived = null, $limit = null, $number = null, $filter = null, $sort = null, $tag = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlags';
        $request = $this->getFeatureFlagsRequest($project_key, $env, $summary, $archived, $limit, $number, $filter, $sort, $tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureFlagsAsync
     *
     * Get a list of all features in the given project.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     * @param  bool $summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned. (optional)
     * @param  bool $archived When set to 1, archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags. (optional)
     * @param  float $limit The number of objects to return. Defaults to -1, which returns everything. (optional)
     * @param  bool $number Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. (optional)
     * @param  string $filter A comma-separated list of filters. Each filter is of the form field:value. (optional)
     * @param  string $sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. (optional)
     * @param  string $tag Filter by tag. A tag can be used to group flags across projects. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagsAsync($project_key, $env = null, $summary = null, $archived = null, $limit = null, $number = null, $filter = null, $sort = null, $tag = null)
    {
        return $this->getFeatureFlagsAsyncWithHttpInfo($project_key, $env, $summary, $archived, $limit, $number, $filter, $sort, $tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureFlagsAsyncWithHttpInfo
     *
     * Get a list of all features in the given project.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     * @param  bool $summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned. (optional)
     * @param  bool $archived When set to 1, archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags. (optional)
     * @param  float $limit The number of objects to return. Defaults to -1, which returns everything. (optional)
     * @param  bool $number Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. (optional)
     * @param  string $filter A comma-separated list of filters. Each filter is of the form field:value. (optional)
     * @param  string $sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. (optional)
     * @param  string $tag Filter by tag. A tag can be used to group flags across projects. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagsAsyncWithHttpInfo($project_key, $env = null, $summary = null, $archived = null, $limit = null, $number = null, $filter = null, $sort = null, $tag = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlags';
        $request = $this->getFeatureFlagsRequest($project_key, $env, $summary, $archived, $limit, $number, $filter, $sort, $tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureFlags'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     * @param  bool $summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned. (optional)
     * @param  bool $archived When set to 1, archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags. (optional)
     * @param  float $limit The number of objects to return. Defaults to -1, which returns everything. (optional)
     * @param  bool $number Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. (optional)
     * @param  string $filter A comma-separated list of filters. Each filter is of the form field:value. (optional)
     * @param  string $sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. (optional)
     * @param  string $tag Filter by tag. A tag can be used to group flags across projects. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureFlagsRequest($project_key, $env = null, $summary = null, $archived = null, $limit = null, $number = null, $filter = null, $sort = null, $tag = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFeatureFlags'
            );
        }

        $resourcePath = '/flags/{projectKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($env)) {
            $env = ObjectSerializer::serializeCollection($env, 'multi', true);
        }
        if ($env !== null) {
            $queryParams['env'] = ObjectSerializer::toQueryValue($env);
        }
        // query params
        if ($summary !== null) {
            $queryParams['summary'] = ObjectSerializer::toQueryValue($summary);
        }
        // query params
        if ($archived !== null) {
            $queryParams['archived'] = ObjectSerializer::toQueryValue($archived);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($tag !== null) {
            $queryParams['tag'] = ObjectSerializer::toQueryValue($tag);
        }

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchExpiringUserTargets
     *
     * Update, add, or delete expiring user targets on feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\UserTargetingExpirationForFlags
     */
    public function patchExpiringUserTargets($project_key, $environment_key, $feature_flag_key, $patch_comment)
    {
        list($response) = $this->patchExpiringUserTargetsWithHttpInfo($project_key, $environment_key, $feature_flag_key, $patch_comment);
        return $response;
    }

    /**
     * Operation patchExpiringUserTargetsWithHttpInfo
     *
     * Update, add, or delete expiring user targets on feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\UserTargetingExpirationForFlags, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchExpiringUserTargetsWithHttpInfo($project_key, $environment_key, $feature_flag_key, $patch_comment)
    {
        $returnType = '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags';
        $request = $this->patchExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key, $patch_comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchExpiringUserTargetsAsync
     *
     * Update, add, or delete expiring user targets on feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchExpiringUserTargetsAsync($project_key, $environment_key, $feature_flag_key, $patch_comment)
    {
        return $this->patchExpiringUserTargetsAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key, $patch_comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchExpiringUserTargetsAsyncWithHttpInfo
     *
     * Update, add, or delete expiring user targets on feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchExpiringUserTargetsAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key, $patch_comment)
    {
        $returnType = '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags';
        $request = $this->patchExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key, $patch_comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchExpiringUserTargets'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key, $patch_comment)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling patchExpiringUserTargets'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling patchExpiringUserTargets'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling patchExpiringUserTargets'
            );
        }
        // verify the required parameter 'patch_comment' is set
        if ($patch_comment === null || (is_array($patch_comment) && count($patch_comment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patch_comment when calling patchExpiringUserTargets'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($patch_comment)) {
            $_tempBody = $patch_comment;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchFeatureFlag
     *
     * Perform a partial update to a feature.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlag
     */
    public function patchFeatureFlag($project_key, $feature_flag_key, $patch_comment)
    {
        list($response) = $this->patchFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $patch_comment);
        return $response;
    }

    /**
     * Operation patchFeatureFlagWithHttpInfo
     *
     * Perform a partial update to a feature.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlag, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $patch_comment)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->patchFeatureFlagRequest($project_key, $feature_flag_key, $patch_comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchFeatureFlagAsync
     *
     * Perform a partial update to a feature.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchFeatureFlagAsync($project_key, $feature_flag_key, $patch_comment)
    {
        return $this->patchFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $patch_comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchFeatureFlagAsyncWithHttpInfo
     *
     * Perform a partial update to a feature.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $patch_comment)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->patchFeatureFlagRequest($project_key, $feature_flag_key, $patch_comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchFeatureFlag'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchFeatureFlagRequest($project_key, $feature_flag_key, $patch_comment)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling patchFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling patchFeatureFlag'
            );
        }
        // verify the required parameter 'patch_comment' is set
        if ($patch_comment === null || (is_array($patch_comment) && count($patch_comment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patch_comment when calling patchFeatureFlag'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($patch_comment)) {
            $_tempBody = $patch_comment;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFeatureFlag
     *
     * Creates a new feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagBody $feature_flag_body Create a new feature flag. (required)
     * @param  string $clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlag
     */
    public function postFeatureFlag($project_key, $feature_flag_body, $clone = null)
    {
        list($response) = $this->postFeatureFlagWithHttpInfo($project_key, $feature_flag_body, $clone);
        return $response;
    }

    /**
     * Operation postFeatureFlagWithHttpInfo
     *
     * Creates a new feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagBody $feature_flag_body Create a new feature flag. (required)
     * @param  string $clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlag, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFeatureFlagWithHttpInfo($project_key, $feature_flag_body, $clone = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->postFeatureFlagRequest($project_key, $feature_flag_body, $clone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFeatureFlagAsync
     *
     * Creates a new feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagBody $feature_flag_body Create a new feature flag. (required)
     * @param  string $clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFeatureFlagAsync($project_key, $feature_flag_body, $clone = null)
    {
        return $this->postFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_body, $clone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFeatureFlagAsyncWithHttpInfo
     *
     * Creates a new feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagBody $feature_flag_body Create a new feature flag. (required)
     * @param  string $clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_body, $clone = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->postFeatureFlagRequest($project_key, $feature_flag_body, $clone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFeatureFlag'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagBody $feature_flag_body Create a new feature flag. (required)
     * @param  string $clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFeatureFlagRequest($project_key, $feature_flag_body, $clone = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling postFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_body' is set
        if ($feature_flag_body === null || (is_array($feature_flag_body) && count($feature_flag_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_body when calling postFeatureFlag'
            );
        }

        $resourcePath = '/flags/{projectKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($clone !== null) {
            $queryParams['clone'] = ObjectSerializer::toQueryValue($clone);
        }

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($feature_flag_body)) {
            $_tempBody = $feature_flag_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
